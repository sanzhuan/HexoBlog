title: "回溯法一般方法和经典问题"
date: 2015-08-10 14:46:49
tags: [回溯,算法]
---
## 适用范围
解必须能表示成一个n元组$(X_1,\cdots,X_n)$，其中$X_i$取自某个有穷集$S_i$，求解的解向量满足规范函数$P(X_1,\cdots,X_n)$。这里的规范函数可以是待求极值的函数或者约束条件。

## 和暴力遍历的区别
假定$S_i$大小是$m_i$,暴力法是枚举出所有的n元组（总共$m=m_1m_2 \cdots m_n$个），并逐一测试是否满足P。而回溯的基本思想是不断修改规范函数$P_i(X_1,\cdots,X_i)$去测试正在构造的部分向量$（X_1,\cdots,X_i）$，看是否可能导致最优解，不能就不做进一步的构造。
<!-- more --> 
## 一般解法
设$(X_1,\cdots,X_i-1)$是状态空间树由根到一个节点的路径，$T(X_1,\cdots,X_i-1)$是满足以下条件的节点：对于每个$X_i$，$(X_1,\cdots,X_i)$是根到节点$X_i$的路径；$(X_1,\cdots,X_i)$满足限界函数$B_i(X_1,\cdots,X_i)$。

### 非递归解法
``` c++
/*
每个解都在X（1：n）中生成，每个解一经确定就立刻打印。在(X(1),...,X(k-1))已求出的情况下，T(X(1),...,X(k-1))是X(k)的所有可能取值。B(X(1),...,X(k-1))判断哪些元素X(k)满足约束条件
*/
procedure BackTrack(n)
	iteger k,n;
	local X(1:n);
	k=1;
	while k > 0 do
		if 还剩下有没检查过的X(k)使得X(k)∈T（X(1),...,X(k-1)）and B（X(1),...,X(k-1)）= true 
		then
			if（X(1),...,X(k-1)）是一条已经抵达答案节点的路径
			then
				print X(1),...,X(k)
			endif

			k = k + 1;

		else
			k = k - 1;
		endif
	repeat

```
### 递归解法

``` c++
/*
进去算法时，解向量X（1：n）的X(1),...,X(k-1)已赋值
*/
procedure BackTrack(k)
	global n,X(1:n);
	for 每个X(k)∈T（X(1),...,X(k-1)）and B（X(1),...,X(k-1)）= true
		if（X(1),...,X(k-1)）是一条已经抵达答案节点的路径
			then
				print X(1),...,X(k)
			endif

		call BackTrack(k+1)
	repeat
```

## 经典问题一：n皇后问题
问题描述：n个皇后放置在$n \times n$的棋盘上且使得没有两个皇后可以相互攻击，也就是每两个皇后都不在同一行，同一列或者对角线上。
套用一般解法，代码为：
``` c++
#include <cstdio>
#include <cmath>
#include <cstdlib>
using namespace std;

/* 判断当前列是否可以放置 */
bool place(int *x,int k){
     	for(int i=0;i<k;i++){
		if(x[k] == x[i] || abs(k - i) == abs(x[k] - x[i]))
			return false;
	}
	return true;
}

void NQueens(int n){
	int *x= (int *)malloc(sizeof(int) * n);
	int k = 0;
	x[0] = -1; 
	while(k>=0){
		//下一列
		x[k] = x[k] + 1;
		while(x[k] < n && !place(x,k)){
			x[k] = x[k] + 1;
		}
		// 找到可以放置的列
		if(x[k] < n){
			if(k == n-1){
				for(int i=0;i<n;i++){
					printf("%d ",x[i]);
				}
				printf("\n");
			}
			else{
				k=k+1;    // 下一行 
				x[k] = -1;
			}
		}
		else{
			k = k - 1;    //回溯
		}
	}
	free(x);
}

int  main(int argc,char *argv[]){
	NQueens(4);	
	NQueens(8);	
}
```

## 经典问题二：子集和数问题
假定n个正数，$w_i$,$1\le i \le n$,和M，要求找出$w_i$的和数是M的所有子集。例如n=4,$(w_1,w_2,w_3,w_4)=(11,13,24,7)$和 M=31 则满足要求的子集是（11,13,7）和（24,7）。
``` c++
#include <cstdio>
#include <algorithm>
using namespace std;

void sumofsub(int *w,bool *x,int M,int s,int k,int r){

	x[k] = 1;
	if(s + w[k] == M){
		for(int i=0;i<4;i++){
			printf("%d ",x[i]);
		}
		printf("\n");
	}
	else if(s+w[k]+w[k+1] <= M){
		sumofsub(w,x,M,s+w[k],k+1,r-w[k]);
	}
	
	if(s+r - w[k] >= M && s+w[k+1] <= M){
		x[k] = 0;
		sumofsub(w,x,M,s,k+1,r-w[k]);
	}

}

int main(int argc,char *argv[]){
	bool x[4] = {0};
	int w[4] = {11,13,24,7};
	sort(w,w+4);
	sumofsub(w,x,31,0,0,55);
}
```
## 经典问题三：图着色问题

已知一个图G和m>0种颜色，在只准使用这m种颜色对G的节点着色的情况下，是否能使得图中任何相邻的两个节点都有不同的颜色呢？
``` c++
#include <cstdio>
#include <cstdlib>
using namespace std;
/* 对第K个节点产生一个合法的颜色 */
int nextValue(int m,int n,int k,int *x,bool graph[][4]){
	while(true){
		x[k] = ( x[k] + 1 ) % (m+1);
		if(x[k] == 0)
			return 0;
		int i=0;
		for(i = 0;i<n;i++){
			if(graph[i][k] && x[k] == x[i])
				break; 
		}

		if(i == n){
			return x[k];
		}
	}

}

void mcoloring(int m,int n,int k,int *x,bool graph[][4]){

		while( nextValue(m,n,k,x,graph)) {
			if(k == n-1){
				for(int i=0;i<n;i++){
					printf("%d ",x[i]);
				}
				printf("\n");
			}
			else
				mcoloring(m,n,k+1,x,graph);
		}
}

int main(int argc,char *argv[]){

	bool graph[4][4] = {{0,1,0,1},{1,0,1,0},{0,1,0,1},{1,0,1,0}};
	int x[4]={0};

	mcoloring(3,4,0,x,graph);
}
```
## 经典问题四：哈密尔顿环
```
#include <cstdio>
#include <cstdlib>
using namespace std;

int nextValue(int n,int k,int *x,bool graph[][8]){
	while(true){
		x[k] = ( x[k] + 1 ) % (n+1);
		if(x[k] == 0)
			return 0;
		int i=0;
		if(graph[ x[k-1] - 1 ][ x[k] -1 ]){
			for(i = 0;i<k;i++){
				if(x[i] == x[k])
					break; 
			}
		}

		if(i == k){
			if(k < n-1)
				return x[k];
			else if(k == n-1 && graph[ x[n-1] - 1 ][0])
			{		
				for(int i=0;i<n;i++){
					printf("%d ",x[i]);
				}
				printf("\n");
			}
		}
	}

}

void hamiltonian(int n,int k,int *x,bool graph[][8]){

	while( nextValue(n,k,x,graph)) {
		if(k < n-1)
			hamiltonian(n,k+1,x,graph);
	}
}

int main(int argc,char *argv[]){

	bool graph[8][8] = {
			    {0,1,1,0,0,0,1,0},
			    {1,0,1,0,0,0,0,1},
			    {1,1,0,1,0,1,0,0},
			    {0,0,1,0,1,0,0,0},
			    {0,0,0,1,0,1,0,0},
			    {0,0,1,0,0,0,1,0},
			    {1,0,0,0,0,1,0,1},
			    {0,1,0,0,0,0,1,0}
			};
	int x[8]={0};
	x[0] = 1;
	hamiltonian(8,1,x,graph);
}
```