title: "网易笔试题"
date: 2015-10-01 10:21:01
tags: c++
---
1.统计文本中单词出现的次数，并按次数排序输出，相同次数的，按字符序升序输出。
2.ipv4地址不小心删掉了所有的‘.’，恢复ip。
3.给定好友关系，求朋友圈的个数。
<!-- more --> 
## 统计文本中单词出现的次数，并按次数排序输出，相同次数的，按字符序升序输出
``` cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <string>
#include <sstream>
using namespace std;

bool cmp(const pair<string,int>&p1,const pair<string,int>&p2){
	if(p1.second > p2.second)
		return true;

	if(p1.second == p2.second)
		return p1.first <  p2.first;	
}

int main(int argc,char *argv[]){

	int n;
	cin >> n;
	map<string,int> m;

	string line;
	string word;
	for(int i=0;i<=n;i++){
		getline(cin,line);
		stringstream ss(line);
		while(getline(ss,word,' ')){
			m[word]++;
		}
	}
	vector< pair<string,int> > vec(m.begin(),m.end());

	sort(vec.begin(),vec.end(),cmp);
	for(vector< pair<string,int> >::iterator it=vec.begin();it  != vec.end();it++){
		cout << (*it).first << " " << (*it).second << endl;

	}
}
```
## ipv4地址不小心删掉了所有的‘.’，恢复ip.
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

void restore(string s, int startIndex, int step, string ip,vector<string> &result) {

	if (startIndex == s.size() && step == 4) { 
		ip.resize(ip.size() - 1);
		result.push_back(ip);
		return;
	}

	if (s.size() - startIndex > (4 - step) * 3)
		return; 
	if (s.size() - startIndex < (4 - step))
		return; 

	int num = 0;
	for (int i = startIndex; i < startIndex + 3; i++) {
		num = num * 10 + (s[i] - '0');
		if (num <= 255) { 
			ip += s[i];
			restore(s, i + 1, step + 1, ip + '.', result);
		}
		if (num == 0) break; 
	}
}

int main(int argc,char *argv[]){
	vector<string> result;
	string s;
	string ip;
	cin >> s;
	restore(s, 0, 0, ip, result);
	sort(result.begin(),result.end());
	for(vector<string>::iterator it = result.begin();it!= result.end();it++){
		cout << *it << endl;
	}
}
```
## 给定好友关系，求朋友圈的个数
``` cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

class set_node
{
public:
    int key;
    set_node* flag;
    set_node* next;
    set_node(int c,set_node* f,set_node* n);
};
 
class set
{
public:
    set_node* head;
    set_node* tail;
    int size;
    set(set_node* h,set_node* t, int s);
}; 

set_node::set_node(int c,set_node* f,set_node* n)
{
    key=c;
    flag=f;
    next=n;
}
 
 
set::set(set_node* h,set_node* t, int s)
{
    head=h;
    tail=t;
    size=s;
}
 
set* make_set(vector<set*>& vs,int c)
{
    set* new_set=new set(0,0,1);
    set_node* new_node=new set_node(c,0,0);
    new_node->flag=new_node;
    new_set->head=new_node;
    new_set->tail=new_node;
    vs.push_back(new_set);
    return new_set;
}
 
set* find_set(vector<set*>& vs,int c)
{
  set_node* temp;
 for(int i=0;i<vs.size();++i)
 {
     temp=vs[i]->head;
     while(temp)
     {
         if(temp->key==c)
             return vs[i];
        temp=temp->next;
     } 
 
 }
 return 0;
}
 
void set_union(vector<set*>& vs,int c1,int c2)
{
  set* sc1=find_set(vs,c1);
  set* sc2=find_set(vs,c2);
  sc1->tail->next=sc2->head;
  for(int i=0;i<sc2->size;++i)
  {
      sc2->head->flag=sc1->head;
      sc2->head=sc2->head->next;
  }
  sc1->size+=sc2->size; 
  sc1->tail=sc1->tail->next;
  vs.erase(find(vs.begin(),vs.end(),sc2),find(vs.begin(),vs.end(),sc2)+1);
}
 
void print(vector<set*>& vs)
{
    typedef vector<set*>::const_iterator vsci;

    vector<int> stat;
    for(vsci vci=vs.begin();vci!=vs.end();++vci)
    {
        stat.push_back ( (*vci)->size );
     }
	sort(stat.begin(),stat.end(),greater<int>());

     for(vector<int>:: iterator it= stat.begin();it != stat.end();it++)
		cout << *it << endl; 
}
 

int main(int argc,char *argv[]){
	int n;
	cin >> n;
	int p,q;
        vector<set*> vs;
	while (cin >> p >> q)
	{
		if(find_set(vs,p) == NULL)
			make_set(vs,p); 
		if(find_set(vs,q) == NULL)
			make_set(vs,q); 
		
		set_union(vs,p,q);
	}
	print(vs);
}
```