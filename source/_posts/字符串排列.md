title: "字符串排列"
date: 2015-08-05 19:28:03
tags: c++
---
## 题目
输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串“abc”，打印出来的排列为：abc、acb、bac、bca、cab和cba。
<!-- more -->
## 若字符串中无重复字符
剑指offer上的思路：
分治法。整个字符串的排列可以看做第一个字符和其它字符。分两步，第一步：先找出可能出现在第一个位置的所有字符。这一步通过把第一个字符和后面的字符交换完成；第二步：求除第一个字符外其它字符的排列。以三个字符“abc”为例。首先固定第一个字符a，求后面两个字符bc的排列。当两个字符bc的排列求好之后，我们把第一个字符a和后面的b交换，得到bac，接着我们固定第一个字符b，求后面两个字符ac的排列。同样地，把*原始字符串*的第一个位置上的字符a与c交换，c现在在第一个位置，固定c，求后面两个字符ba的排列。同样地，求后面两个字符的排列也可以按上面思路进行，这是典型的递归过程。

``` c++
 void Permutation(char* pStr)
{
    if(pStr == NULL)
        return;

    Permutation(pStr, pStr);
}

void Permutation(char* pStr, char* pBegin)
{
    if(*pBegin == '\0')
    {
        printf("%s\n", pStr);
    }
    else
    {
        for(char* pCh = pBegin; *pCh != '\0'; ++ pCh)
        {
        	//交换
            char temp = *pCh;
            *pCh = *pBegin;
            *pBegin = temp;

            //求出其他字符的所有排列
            Permutation(pStr, pBegin + 1);

            //上一步的交换改变了原始字符，所以这里要交换还原原始字符串
            temp = *pCh;
            *pCh = *pBegin;
            *pBegin = temp;
        }
    }
}
```

## 字符串中有重复字符
剑指offer上面没有考虑字符串有重复字符的情况，如果采用上面的算法，结果是错的。比如输入“aabc”，得出的结果就出现了重复情况。那么，问题来了，怎么改进上面的算法避免重复计算呢。一个简单的思路就是碰到重复字符的时候就不执行，也就是说要判断当前字符是否已经在前面出现过了，出现过了就不再重复计算。
``` c++
void Permutation(char* pSrc,  char* pBegin)  
{  
    if (!pSrc || !pBegin)  
    {  
        return;  
    }  
  
    if (*pBegin == '\0')  
    {  
        printf("%s\n", pSrc);  
    }  
    else  
    {  
        for (char* pCh=pBegin; *pCh!='\0'; ++pCh)  
        { 
        	//前面出现过就不再执行，避免重复。 
            if(strchr(pBegin, *pCh) == pCh)  
            {  
                char temp = *pBegin;  
                *pBegin = *pCh;  
                *pCh = temp;  
  
                Permutation(pSrc, pBegin+1);  
  
                temp = *pBegin;  
                *pBegin = *pCh;  
                *pCh = temp;  
            }  
        }  
    }  
}
```