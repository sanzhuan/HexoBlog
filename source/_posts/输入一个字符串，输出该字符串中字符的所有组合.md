title: "输入一个字符串，输出该字符串中字符的所有组合"
date: 2015-07-05 22:09:46
tags: [算法,递归]
---

##输入一个字符串，输出该字符串中字符的所有组合。比如输入abc，它的组合有a、b、c、ab、ac、bc、abc。
<!-- more --> 
##解题思路
拿到这道题，直接的想法是找规律。但是，找规律这种事不太靠谱。说不定，你自己就找不到呢。其实，可以这样考虑。不是要找出字符串的所有组合吗，有没有可能分别找字符串的两个子串的所有组合，然后再拼起来。沿着这个思路，可以想到，其实找字符串第一字符拼上剩下其他字符的组合，和剩下其他字符的组合。同样地，找剩下其他字符的组合，也可以看做是第一个字符拼上剩下其他字符的组合。可以发现，这是个递归的结构，划分后的问题是原问题的子问题。这样说有点绕，可以看个例子。比如abc,可以看做是a和bc组合的拼接，bc可以看做是b和c组合的拼接，而c组合可以看做是c和'\0'组合的拼接。'\0'的组合就是'\0',所以c组合就是"c\0"和"\0",如此逆推回去。


``` c++
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
using namespace std;

char *chartoString(char ch)
{
    char *str=(char *)malloc(sizeof(char)*2);
    str[0]= ch;
    str[1] ='\0';
    return str;
}
void combine(char *string,vector<char *> &result)
{
    if(*string == '\0')
    {
        result.push_back( chartoString('\0') );
        return;
    }
    combine(string+1,result);
    int otherCombineSize = result.size();
    for(int i=0;i<otherCombineSize;i++)
        result.push_back(strcat(chartoString(string[0]),result[i]));    
}

int main(int argc,char *argv[])
{
    if(argc != 2){
        printf("usage:./combine \"str\"");
        exit(1);
    }
        
    vector<char *> result;
    combine(argv[1],result);

    for(int i=0;i<result.size();i++)
        printf("%s ",result[i]);
    printf("\n");
}
```