title: "输入一个字符串，输出该字符串中字符的所有组合"
date: 2015-07-05 22:09:46
tags: [算法,递归]
---

##输入一个字符串，输出该字符串中字符的所有组合。比如输入abc，它的组合有a、b、c、ab、ac、bc、abc。

##解题思路
拿到这道题，直接的想法是找规律。但是，找规律这种事不太靠谱。说不定，你自己就找不到呢。其实，可以这样考虑。不是要找出字符串的所有组合吗，有没有可能分别找字符串的两个子串的所有组合，然后再拼起来。沿着这个思路，可以想到，其实找字符串第一字符拼上剩下其他字符的组合，和剩下其他字符的组合。同样地，找剩下其他字符的组合，也可以看做是第一个字符拼上剩下其他字符的组合。可以发现，这是个递归的结构，划分后的问题是原问题的子问题。这样说有点绕，可以看个例子。比如abc,可以看做是a和bc组合的拼接，bc可以看做是b和c组合的拼接，而c组合可以看做是c和'\0'组合的拼接。'\0'的组合就是'\0',所以c组合就是"c\0"和"\0",如此逆推回去。
<!-- more --> 

代码如下：
``` c++
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
using namespace std;

char *chartoString(char ch)
{
    char *str=(char *)malloc(sizeof(char)*2);
    str[0]= ch;
    str[1] ='\0';
    return str;
}
void combine(char *string,vector<char *> &result)
{
    if(*string == '\0')
    {
        result.push_back( chartoString('\0') );
        return;
    }
    combine(string+1,result);
    int otherCombineSize = result.size();
    for(int i=0;i<otherCombineSize;i++)
        result.push_back(strcat(chartoString(string[0]),result[i]));    
}

int main(int argc,char *argv[])
{
    if(argc != 2){
        printf("usage:./combine \"str\"");
        exit(1);
    }
        
    vector<char *> result;
    combine(argv[1],result);

    for(int i=0;i<result.size();i++)
        printf("%s ",result[i]);
    printf("\n");
}
```

## 另外一种解法
同样基于递归，假设我们想在长度为n的字符串中求m个字符的组合。针对第一个字符，我们有两种选择：第一是把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选取m-1个字符；第二是不把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选择m个字符。下面是这种思路的参考代码：
``` c++
void Combination(char *string)  
{  
    assert(string != NULL);  
    vector<char> result;  
    int i , length = strlen(string);  
    for(i = 1 ; i <= length ; ++i)  
        Combination(string , i ,result);  
}  
  
void Combination(char *string ,int number , vector<char> &result)  
{  
    assert(string != NULL);  
    if(number == 0)  
    {  
        static int num = 1;  
        printf("第%d个组合\t",num++);  
  
        vector<char>::iterator iter = result.begin();  
        for( ; iter != result.end() ; ++iter)  
            printf("%c",*iter);  
        printf("\n");  
        return ;  
    }  
    if(*string == '\0')  
        return ;  
    result.push_back(*string);  
    Combination(string + 1 , number - 1 , result);  
    result.pop_back();  
    Combination(string + 1 , number , result);  
}  
```
## 有重复字符
如果输入的字符串有重复字符，我能想到的是先unique，再用上面的算法。如果有什么好的算法，请不惜赐教。