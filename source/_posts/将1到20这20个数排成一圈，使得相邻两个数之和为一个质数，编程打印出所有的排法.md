title: "将1到20这20个数排成一圈，使得相邻两个数之和为一个质数，编程打印出所有的排法"
date: 2015-07-05 22:45:53
tags: [算法,回溯]
---
##解题思路：
拿到这个题，最直接的想法是遍历。但是，遍历的时间复杂度比较高，那么有没有其他的方法来优化呢。其实，回溯法就是对遍历的优化。针对这道题，直接套用回溯法，即可解。
<!-- more --> 
##递归解法

``` c++
#include <stdio.h>
#include <math.h>

int isPrime(int i,int j)
{
    int sum = i + j + 2;

    for(int k = 2; k <= (int)sqrt(sum); k++){
        if( sum % k == 0 )
            return 0;
    }

    return 1; 
}

int notEqualPre(int *x,int k,int column){
    for(int i=0;i<k;i++)
        if( column + 1 == x[i])
            return 0;
    return 1;
}

int recursePrint(int *x,int isPrimeArray[][20],int k){

    if(k ==  20){
        if(isPrimeArray[x[k-1] - 1][0]){
            for(int j=0;j<20;j++){

                printf("%d ",x[j]);
            }
            printf("\n");
        }
        return 1;
    }

    for(int i = 0 ; i < 20 ; i++){

        if( isPrimeArray[x[k - 1] - 1][i] && notEqualPre(x,k,i) ){
            x[k] = i + 1;
            recursePrint(x,isPrimeArray,k+1);
        }
    }
}

int main(int argc,char *argv[])
{
    int isPrimeArray[20][20]={0};

    for(int i=0;i<20;i++){
        for(int j=0;j<20;j++){
            if( i != j && isPrime(i,j) ){
                isPrimeArray[i][j] = 1;
            }
        }
    }

    int x[20]={0};

    int k=1;
    x[0] = 1;
    recursePrint(x,isPrimeArray,k);
}
```
## 非递归解法
``` C++
#include <stdio.h>
#include <math.h>

int isPrime(int i,int j)
{
    int sum = i + j + 2;

    for(int k = 2; k <= (int)sqrt(sum); k++){
        if( sum % k == 0 )
            return 0;
    }

    return 1; 
}

int notEqualPre(int *x,int k,int column){
    for(int i=0;i<k;i++)
        if( column + 1 == x[i])
            return 0;
    return 1;
}

int main(int argc,char *argv[])
{
    int isPrimeArray[20][20]={0};

    for(int i=0;i<20;i++){
        for(int j=0;j<20;j++){
            if( i != j && isPrime(i,j) ){
                isPrimeArray[i][j] = 1;
            }
        }
    }

    int x[20]={0};

    int k=1;
    x[0] = 1;

    int nextColumn[20]={0}; 
    while(k>0){
LABEL:
          if(k ==  20){
              if(isPrimeArray[x[k-1] - 1][0]){
                  for(int j=0;j<20;j++){
                     
                      printf("%d ",x[j]);
                  }
                  printf("\n");
              }
          }
    for(int i = nextColumn[k-1] ; i < 20 ; i++){
          nextColumn[k-1] = i + 1;


          if( isPrimeArray[x[k - 1] - 1][i] && notEqualPre(x,k,i) ){

              x[k] = i + 1;
              if(k ==  20){
                  if(isPrimeArray[x[k-1] - 1][0]){
                      for(int j=0;j<20;j++){
                          printf("x[]={%d ",x[j]);
                      }
                  }
              }
              else{
                  k = k + 1;
                  goto LABEL;
              }
          }
      }
      k = k - 1;
      if(nextColumn[k] >= 20){
          nextColumn[k] = 0;
          x[k] = 0;
      }
    }
}
```